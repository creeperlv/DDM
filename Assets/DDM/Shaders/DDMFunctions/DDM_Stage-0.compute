// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel FirstPass
#pragma kernel SecondPass
#define MAX_X 256
// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
//IN

StructuredBuffer<float4x4> BoneM;
StructuredBuffer<float4> BoneBinding; //Per Vertex
StructuredBuffer<float3> Vertices;
StructuredBuffer<float3> Normals;
StructuredBuffer<float4x4> Psis;

RWStructuredBuffer<float3> O_Vert;
RWStructuredBuffer<float3> O_Nor;
RWStructuredBuffer<float3x3> USVs;
StructuredBuffer<float3x3> Rs;
RWStructuredBuffer<float3x1> q_s;
RWStructuredBuffer<float3x1> p_s;
float3x3 Multiply(float3x1 A, float1x3 B)
{
    float3x3 USV;
    
    for (int y = 0; y < 3; y++)
        for (int x = 0; x < 3; x++)
        {
            USV[x][y] = A[x][0] * B[0][y];
        }
    return USV;
}
[numthreads(MAX_X, 1, 1)]
void FirstPass(uint3 id : SV_DispatchThreadID)
{
    float4 vertBB = BoneBinding[id.x];
    //float4x4 Psi = Psis[id.x];
    float4x4 Psi0 = Psis[id.x + 4 + 0];
    float4x4 Psi1 = Psis[id.x + 4 + 1];
    float4x4 Psi2 = Psis[id.x + 4 + 2];
    float4x4 Psi3 = Psis[id.x + 4 + 3];
    float4x4 B0 = BoneM[vertBB.x];
    float4x4 B1 = BoneM[vertBB.y];
    float4x4 B2 = BoneM[vertBB.z];
    float4x4 B3 = BoneM[vertBB.w];
    float4x4 Omega = B0 * Psi0 + B1 * Psi1
    + B2 * Psi1 + B3 * Psi3;
    float3x3 Q;
    for (int x = 0; x < 3; x++)
        for (int y = 0; y < 3; y++)
            Q[x][y] = Omega[x][y];
    float3x1 q = float3x1(Omega[0][0], Omega[1][0], Omega[2][0]);
    //q[0] = Omega[0, 0];
    //q[1] = Omega[1, 0];
    //q[2] = Omega[2, 0];
    float1x3 pT = float1x3(Omega[3][0], Omega[3][1], Omega[3][2]);
    //pT[0][0] = Omega[3, 0];
    //pT[0][1] = Omega[3, 1];
    //pT[0][2] = Omega[3, 2];
    float3x1 p = float3x1(pT[0][0], pT[0][1], pT[0][2]);
    //p[0] = pT[0][0];
    //p[1] = pT[0][1];
    //p[2] = pT[0][2];
    //float3x3 USV = Q - q * pT;
    USVs[id.x] = Q - Multiply(q, pT);
    //Result[id.xy] = float4(id.x & id.y, (id.x & 15) / 15.0, (id.y & 15) / 15.0, 0.0);
}
float3 Float4x4ByFloat3(float4x4 L, float3 R)
{
    float3 result;
    result.x = L[0][0] * R.x + L[0][1] * R.y + L[0][2] * R.z + L[0][3];
    result.y = L[1][0] * R.x + L[1][1] * R.y + L[1][2] * R.z + L[1][3];
    result.z = L[2][0] * R.x + L[2][1] * R.y + L[2][2] * R.z + L[2][3];
    return result;
}
float3 Float4x4ByFloat3__(float4x4 L, float3 R)
{
    float3 result;
    result.x = L[0][0] * R.x + L[0][1] * R.y + L[0][2] * R.z; // + L[0][3];
    result.y = L[1][0] * R.x + L[1][1] * R.y + L[1][2] * R.z; // + L[1][3];
    result.z = L[2][0] * R.x + L[2][1] * R.y + L[2][2] * R.z; // + L[2][3];
    return result;
}
[numthreads(MAX_X, 4, 1)]
void SecondPass(uint3 id : SV_DispatchThreadID)
{
    float4x4 Trans;
    float3x3 R = Rs[id.x];
    for (int x = 0; x < 3; x++)
        for (int y = 0; y < 3; y++)
            Trans[x][y] = R[x][y];
    float3x1 T = q_s[id.x] - R * p_s[id.x];
    Trans[0][3] = T[0];
    Trans[1][3] = T[1];
    Trans[2][3] = T[2];
    Trans[3][3] = 1;
    O_Vert[id.x] = Float4x4ByFloat3(Trans, Vertices[id.x]);
    O_Nor[id.x] = Float4x4ByFloat3__(Trans, Normals[id.x]);

}
